# The SwiftUI render loop

| Грейд  | Middle                                |
|--------|---------------------------------------|
| Секция | SwiftUI                               |
| Авторы | https://rensbr.eu/blog/swiftui-render-loop/|

Так же как и **UIKit**, в **SwiftUI** реализован цикл событий, который отправляет сообщения в UIную часть кода, где 
UI интерфейс, в свою очередь, может инициировать повторную отрисовку частей экрана, 
где обработка сообщений и отображение графики на экране образуют цикл рендеринга приложения. 
Все фреймворки пользовательского интерфейса основаны на цикле отрисовки и 
большую часть времени цикл отрисовки работает под капотом, и нам не нужно ничего об этом знать - это 
удивительно, так как мы можем писать UI код и даже не понимая, что такое цикл событий, и не беспокоясь о том, как часто отображать содержимое экрана. 
Но в некоторых случаях полезно знать, что происходит "под капотом".

Сначала мы рассмотрим ряд примеров таких случаев, когда полезно знать, как работает цикл отрисовки SwiftUI. 
Затем мы рассмотрим цикл отрисовки более подробно и зададим такие вопросы: когда именно `body` будет пересмотрено для отрисовки в SwiftUI. 
Даже не "когда", а при каких обстоятельствах: 
 - В какой момент времени? 
 - Всегда ли `view` отображается на экране сразу после пересмотра `body`? 
 - Насколько вообще связаны - пересмотр `body` и рендеринг экрана? 
 - Мы иногда используем слово "рендеринг" для пересмотра вьюшки на перерисовку, имеет ли это вообще смысл?

# onAppear
В SwiftUI у нас нет столь много функций из жизненного цикла `UIViewController`, которые мы знаем из UIKit. 
Если мы хотим выполнить действие при появлении `view` элемента, то мы можем использовать только одну функцию: `onAppear`. 
Но когда именно `onAppear` вызывается? 
Вызывается ли он до того, как представление будет отображено и станет видимым на экране, как вo `viewWillAppear?` 
И если да, можем ли мы на это положиться?

Давайте рассмотри вот такой пример:
```
class UserViewModel: ObservableObject {
    @Published var userName: String = "Alex"

    func fetch() {
        self.userName = "loading"
        // ...
    }
}

struct ContentView: View {
    @StateObject var model = UserViewModel()

    var body: some View {
        Text(model.userName)
            .font(.t1Medium)
            .onAppear { model.fetch() }
    }
}
```

Эта вьюшка готова к отображению только после `fetch` вызова функции вьюмодели в `onAppear`.
Если мы протестируем, то все будет окей. Что происходит на медленном iPhone или на быстром iPhone, который способен отобразить намного больше кадров? 
Может ли нам не повезти с частотой обновления дисплея, чтобы надпись "loading" мигала до изменений на "Alex"? 
Кроме того, может ли это причинить нам проблемы, если мы добавим переходы из `ContentView` дальше? Насколько это неэффективно? 
Мы можем видеть, что `body` будет пересмотрено дважды. А будет ли содержимое отрисовываться дважды?

# Кастомная вёрстка с preference keys
Мы можем встретиться с такой вёрсткой, которую невозможно будет создать с помощью одних только базовых инструментов, таких как stacks, alignment guides и frames. 
Для вёрстки элементов, где вьюшка должна знать размер своих дочерних представлений, этих инструментов может быть недостаточно.

В качестве примера, допустим, нам нужно представление контейнера, которое ведет себя как **HStack**, пока его дочерние элементы больше 
не будут помещаться на экран, после чего он должен продолжить размещение дочерних элементов в следующей строке, например:

![image](https://user-images.githubusercontent.com/47610132/202817665-f5a9990e-53b3-4eec-9ab2-39a0c43449be.png)

Вот решение такой задачи:
```
struct Flow<Content: View>: View {
  let content: [Content]

  @State private var sizes: [CGSize] = []

  var body: some View {
    ZStack(alignment: .topLeading) {
      ForEach(0 ..< sizes.count, id: \.self) { i in
        content[i]
          .background(GeometryReader {
            Color.clear
              .preference(key: SizesPreferenceKey.self, value: [$0.size])
          })
          .offset(self.calculateOffset(i)) // uses self.sizes
        }
      }
    }
    .onPreferenceChange(SizesPreferenceKey.self) {
      sizes = $0
    }
  }

  // ...
}
```

Сначала мы создадим `@State` переменную, которая будет содержать размеры дочерних элементов. 
Затем мы используем `GeometryReader*` в бэкграунде дочерних вьюх, чтобы прочитать их размер, и передать эту информацию во вью.
Вернувшись в родительскую вьюшку, мы можем использовать эти настройки в `onPreferenceChange` обработчике для обновления состояния. 
С помощью переменной sizes дочерние вьюшки теперь могут быть расположены правильно.

Этот трюк работает, но `body` вьюшки-контейнера необходимо пересмотреть дважды. При первом проходе, перменная `sizes` еще не заполнена, 
поэтому она еще не может правильно расположить дочерние элементы. При проходе по дочерним элементам, `size preference` обновляется. 
Затем `body` вьюшки-контейнера оценивается во второй раз, где уже может правильно разместить свое содержимое.

При первом пересмотре вьюшки - оно еще не готово к отображению, поэтому мы должны задать себе те же вопросы, что и в первом примере. 
Только теперь двойной пересмотр `body` может происходить чаще, чем при первом отображении. 
Можем ли мы быть уверены, что представление контейнера никогда не отображается с исходной, еще некорректной вёрсткой? 
Сколько ненужной отрисовки мы выполняем?

`*GeometryReader` - используйте с умом. Т.к использовав его направо и налево может привезти к лоу фпс.

# Аппаратная симфония
Имея базовые знания о низкоуровневых технологиях, используемых в iOS для обработки таких событий, как касания и отображение содержимого на экране, мы теперь можем рассмотреть полный цикл рендеринга SwiftUI.

![image](https://user-images.githubusercontent.com/47610132/203855703-1ecdbdef-d313-4f97-a3e2-81271161b6ca.png)

Когда юзер ничего не делает, приложение SwiftUI будет бездействовать с `CFRunLoop`. 
Ранлуп будет ожидать событий от `источников ввода (input source)`: касания, сетевые события, таймеры или обновление дисплея. 
В ответ на касание SwiftUI может вызвать обработчик действия кнопки. Если мы поместим брекпоинт внутри этого обработчика действия, 
мы увидим `__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__` где-нибудь в трассировке стека. 
Это связано с тем, что события касаний доставляются из [0 input source.](https://stackoverflow.com/questions/65767035/where-is-object-id-of-0-coming-from-in-this-swift-code-that-is-supposed-to-pass)

В ответ на действие, которое мы выполняем в ответ на событие из `input source`, мы можем обновить некоторую `@State` переменную в представлении 
или вызвать функцию для `@ObservedObject`, которая, в свою очередь, вызывает запуск ее `objectWillChange`. 
В этом случае вьюшка SwiftUI становится инвалидированным - это означает, что её тело необходимо пересмотреть, но было бы неэффективно делать это немедленно. 
Возможно, та же функция, которая изменила `@State` переменную, изменит другую `@State` переменную. 
Поэтому пересмотр `body` планируется выполнять позже.

Если мы поместим брейкпоинт в любую точку `body` вьюшки, то мы сможем увидеть `__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__` -
в трассировке стека. Точно так же, как планирование неявного `CATransaction`, пересмотр для инвалидированного `body` вью элемента
планируется выполнить в конце текущего цикла ранлупа. Это снова реализуется с помощью наблюдателя цикла выполнения, который наблюдает, 
когда цикл выполнения входит в `CFRunLoopActivity.beforeWaiting` стадию. Если вью дважды становится инвалидированным в одном и том же цикле выполнения, 
оно не будет пересматриваться для отрисовки дважды.

После того, как все инвалидированные вью элементы были повторно пересмотрены для отрисовки, SwiftUI не сразу возвращает управление обратно в ранлуп. 
Сначала вызываются обработчики изменений, такие как `onChange` или `onPreferenceChange` и `onAppear` - 
эти обработчики могут сделать вью элементы инвалидированны во второй раз. 
Для второго пересмотра отображения вью элемента - SwiftUI не использует наблюдателя из ранлупа.

Если этот второй пересмотр `body` снова вызовет обработчик изменений и это приведет к еще одной инвалидированному вью элемента, 
то SwiftUI временно отключит инвалидированность для вьюшки, чтобы предотвратить бесконечные циклы. Он также выведет предупреждение, подобное этому:

`onChange(of: _) action tried to update multiple times per frame`

При повторном пересмотре вью, встроенные вью `(с типом Never)` могут вносить изменения в `CALayer`. 
Как мы видели, эти изменения не отображаются на экране немедленно, но они запускают неявное `CATransaction` отображение.
Таким образом, SwiftUI использует ту же оптимизацию, которую мы использовали вручную в приложениях UIKit.

Только когда зафиксировано неявный `CATransaction`, содержимое вью элементов отображается на экране. 
Это также момент, когда вызывается код рендеринга, использующий центральный процессор. 
Если SwiftUI выходит из строя в этой части цикла рендеринга, [может быть трудно понять](https://steipete.com/posts/state-of-swiftui/) как это исправить, 
потому что трудно увидеть, какая часть какого представления вызвала это.

В цикле рендеринга существует общий шаблон, используемый для оптимизации кода и обеспечения того, чтобы он вызывался столько раз, сколько необходимо. 
Когда вызов функции или изменение переменной запускает обновление, это обновление выполняется не сразу. 
Вместо этого это запланировано на более позднее время. Это происходит, когда вьюшки становятся инвалидируются из-за изменения их состояния, 
когда вызываются обработчики, такие как `onChange` или `onAppear`, и когда основной анимации необходимо нарисовать графику. 
Некоторые из них используют наблюдателей из `CFRunLoop`, и иногда это обрабатывается внутри фреймворка.

Зная цикл рендеринга, мы можем понять, почему безопасно использовать код, как в примерах в начале. 
Ни одно из изменений после первого пересмотра `body` не отображается, поскольку неявная транзакция, частью которой они являются, еще `не зафиксирована.` 
Также полезно знать, что делает SwiftUI при отладке или попытке повысить производительность.

Цикл рендеринга в SwiftUI может быть хорошо скрыт, технологии, которые он использует, те же, что мы использовали в приложениях UIKit, 
и они хорошо документированы. Если мы лучше разберемся в том, как это работает, мы сможем лучше понять побочные эффекты кода, который мы пишем, и принимать лучшие решения. 
Иногда мы можем сказать "рендеринг" для вью, если имеем в виду оценку его `body`. Но иногда понимание различия может быть очень полезным.

# Дополнительные ресурсы

- [The SwiftUI Render Loop](https://mjtsai.com/blog/2022/09/04/the-swiftui-render-loop/)
- [SwiftUI View Lifecycle](https://www.vadimbulavin.com/swiftui-view-lifecycle/)
