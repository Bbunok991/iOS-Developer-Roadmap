# Что такое optional в swift и как он используются
`Optional` - механизм, указывающий на возможное отсутствие значения или ссылки на объект. 
Хоть и на понимание опциональности может потребоваться время, чтобы привыкнуть, для тех кто не знаком с этой концепцией, но использование опционального типа может сделать код более безопасным и выразительным. 

# Что является optional в Swift
`Optional` является специальным типом в swift, экземпляр которого могут содержать или не содержать значения данного типа.
**Optional** вариант может рассматриваться как коробка, которая предназначена для обуви, если там есть обувь - коробка содержит значение, если обуви нет, коробка не содержит значение.

После создания **опционального** типа, экземпляр может находиться в одном из двух состояний - он либо содержит один экземпляр указанного обернутого типа, либо является пустым. Пустой, опциональный параметр эквивалентен нулю, который является специальным литералом, представляющим отсутствие значения.

Опциональность является настолько важной частью swift, что в язык был встроен специальный синтаксис, чтобы сделать их простыми в использовании.
Мы можем объявить **optional wrapping** любого типа в swift, просто постфиксируя имя типа, который будет упакован с вопросительным знаком `(?)`. Это относится не только к типам в стандартной библиотеке, таким как Int или String, но и к определяемым пользователем типам, включая ссылочные типы (классы и замыкания) и типы значений (структуры, перечисления и кортежи).

В качестве примера мы объявляем опциональный тип **String** в качестве обёрнутого типа и даем ему значение **String** для записи.

```
var justString: String? = "Just a string"
```
Мы можем использовать `type(of:)` функцию, чтобы проверить `justString` и использовать проверку равенства, чтобы подтвердить, что это не равно нолю.
```
print(type(of: justString))    // Optional<String>
print(justString == nil)       // false
```
Приведенная выше конструкция нарушает строгие правила ввода, поскольку мы можем назначить значение **String** переменной типа **Optional<String>**.
Это одна из многочисленных синтаксических удобств, встроенных в swift, чтобы упростить использование опциональности.
При назначении экземпляра обернутого как опциональная переменная, то "под-копотом" создается опциональная оболочка данного экземпляра, которая назначается переменной.
 
Та же автоматическая обертка работает при вызове функций, что означает, что если у нас есть функция с опциональным параметром, мы можем передать в качестве аргумента опциональный экземпляр типа, обернутого как опциональный тип. 
  
Важно отметить, что обратное не соответствует действительности.
Если мы попытаемся назначить опциональную переменную или передать опциональную функцию, которая ожидает экземпляр не опционального типа, то мы получим ошибку.

**Swift** позволяет создавать опциональный тип, без предоставления экземпляра.   
```
var justString: String?
```
Если мы не даем опциональной переменной начальное значение при объявлении, то автоматически создается пустая опциональная переменная, равная нулю, и назначается ей. 
Это единственный случай, когда **Swift** автоматически инициализирует переменную. 
Мы можем подтвердить это, делая тип и равенство проверив **justString**.
```
print(type(of: justString))    // Optional<String>
print(justString == nil)       // true
```
# Почему в Swift есть опциональность
Бывают случаи, когда нам нужно каким-то образом сигнализировать в нашем коде, что значение или ссылка на объект могут существовать или не существовать.
Другой пример, мы хотели бы быть уверенными, что когда мы ожидаем иметь значение или ссылку на объект, он будет там.
В языках, не имеющих встроенной поддержки опционально, где такие гарантии не встроены в язык, это может привести к нежелательным последствиям в коде, таким как ненужная проверка для обеспечения того, чтобы ссылка на объект указывала на фактический объект, или же при работе со `скалярными типами`, используя [sentinel values](https://en.wikipedia.org/wiki/Sentinel_value), которые являются произвольными значениями, имеющими особое значение в данном контексте, например функция предназначенная для возврата индекса массива, возвращающего **-1**, когда нет допустимого значения индекса.

Swift решает эти проблемы с нуля. Во-первых, swift **не имеет скалярных типов**. Все типы в Swift могут свободно называться типами объектов, что означает, что они могут быть созданы и сообщения могут быть отправлены в созданные таким образом экземпляры. 
Это справедливо для всех типов значений и ссылок в swift. Во-вторых, опциональность в swift формализует различие между ситуациями, когда значение или ссылка должны быть доступны, и ситуациями, когда значение или ссылка могут присутствовать или отсутствовать на законных основаниях.

Неопциональная переменная в swift всегда должна иметь значение или ссылку, в зависимости от обстоятельств, и не может использоваться без инициализации. Аналогично, и для функций, где возвращаемый тип не является неопциональным и не будет компилироваться, если функция не возвращает значение или ссылку, в зависимости от того, является ли возвращаемый тип значением или ссылочным типом.
Это обеспечивает железную гарантию того, что если тип переменной, или возвращаемый тип функции не был объявлен как опциональный, то он всегда будет иметь значение или ссылку. 
С другой стороны, если тип переменной или возвращаемый тип функции объявлен как опциональный, то любой код, который использует такую переменную или функцию, 
должен использовать специальный синтаксис, встроенный в язык, не только для проверки того, действительно ли существует значение или ссылка, 
но и для безопасного использования, если это так.
  
# Как реализуется опциональность в Swift
  
```
public enum Optional<Wrapped> {
    case none
    case some(Wrapped)
}
```
Перечисление имеет **два случая**, чтобы представлять `отсутствие` и `присутствие` для экземпляра, который реализует опциональность.
При отсутствии значения - опциональным значением является `.none`.
Если опциональный экземпляр содержит значение, то это значение в `Optional` перечеслении является значением `.some`.
Поскольку параметр `Optional` является универсальным типом (дженерик), то параметр `Wrapped` используется для определения типа обёрнутого экземпляра 
во время создания экземпляра опционального типа.

Это объясняет, почему опциональные элементы, например `String`, `Int`, имеют типы `Optional<String>` и `Optional<Int>` соответственно. 
Хотя мы могли бы объявить опционально с помощью этого синтаксиса, но гораздо удобнее и общепринято использовать `String?` и `Int?` - краткие имена типов. 
Литерал **nil** служит удобным кратким текстом для кейса `.none`.

Опциональный параметр может быть инициализирован нулевым литералом, так как тип **Optional** соответствует протоколу `ExpressibleStartNilLiteral`, который имеет следующее требование:
```
protocol ExpressibleByNilLiteral {
    init(nilLiteral: ())
}
```

`nilLiteral` - пустой кортеж, что означает отсутствие значения. При вызове этого инициализатора создается новый экземпляр `Optional` со значением `.none`.
Ни один другой тип Swift не соответствует этому протоколу, и использование этого протокола с другими типами не рекомендуется во избежание путаницы с `Optional`.
Этот инициализатор не должен вызываться напрямую, он автоматически вызывается компилятором, когда опциональный параметр инициализируется с помощью литерала `nil` (или создается опциональный экземпляр, как пример var example: Int?).
  
# Когда использовать опциональность в Swift
Формализуя концепцию опциональности, swift может помочь нам создать улучшенные модели и написать код, который может явно относиться к случаям,
когда определенные отношения могут присутствовать или отсутствовать для конкретного экземпляра, либо изначально, либо в определенный момент времени.

Мы часто встречаем ситуации, когда определенный результат не может быть гарантирован. Функции могут быть не в состоянии вернуть значение во всех случаях, создание новых экземпляров определенных типов может завершиться неудачей при определенных условиях, не все операции для соответствия типу **(as! или as?)** могут быть успешными и т.д.
Варианты обеспечивают простой и элегантный способ решения таких ситуаций, когда причину неудачи можно определить из контекста.
#
1. Свойства, которые не гарантируют содержание значения
Часто встречаются свойства, которые могут иметь значение для некоторых экземпляров типа, но не имть для других.
Аналогично, могут существовать свойства, которые могут иметь значение в определенные моменты времени, но не в другие.
Опциональные варианты являются естественным выбором для официального выражения таких ограничений. Для иллюстрации давайте определим протокол для моделирования домашних животных и класс для моделирования людей, которые могут владеть этими домашними животными.
```
protocol Pet {
    var name: String? { get set }
    func makeSound()
}

class Person {
    var name: String
    var pet: Pet?
    
    init(named name: String) {
        self.name = name
    }
}
```
Протокол **Pet** объявляет метод, который будет реализовывать звук, который издает каждый питомец.
Он также объявляет свойство для имени домашнего животного. Класс **Person** имеет два свойства: одно для имени человека, а другое для домашнего животного, которым он может обладать.
  
Поскольку не каждый человек может иметь домашнее животное, и тот человек, у которого может - быть один питомец, означается что поле `pet` для класса `Person` будет опциональным.
Так же, имя человека **name** в классе **Person** является обязательным, но кличка питомца **name** в протоколе **Pet** является опциональным, отображая тем самым требование.
  
# 
2. Функция не гарантирует возврат значения
Могут существовать функции, методы или замыкания с объявленными типами возврата, которые могут не вернуть значение.
Обычно это означает, что операция не может быть выполнена по запросу.
  
Например, протокол `Collectio`n в стандартной библиотеке определяет метод `firstIndex(of:)` доступный, когда элементы коллекции соответствуют Equatable,
который возвращает первый индекс, где указанное значение появляется в коллекции. Однако возможно, что значение не отображается в коллекции и именно поэтому
возвращаемый тип метода - это Int?. Если значение найдено, его целочисленный индекс возвращается в виде опционального значение, в противном случае возвращается значение `nil`.

Чтобы продемонстрировать это, мы определяем простую и универсальную функцию, которая ищет первый индекс элемента в массиве,
где элементы массива соответствуют `Equatable`, печатает первый индекс, если элемент найден, и печатает подходящее сообщение, если это не так.
```
func printFirstIndex<Element: Equatable>(of element: Element, in array: [Element]) {
    let maybeIndex = array.firstIndex(of: element)
    if let index = maybeIndex {
        print("Element \(element) was found at index \(index)")
    } else {
        print("Element \(element) not found")
    }
}
```
Вот как мы можем использовать вышеуказанную функцию с массивом целых чисел.
```
let ints = [2, 3, 5]
printFirstIndex(of: 3, in: ints)    // Element 3 was found at index 1
printFirstIndex(of: 7, in: ints)    // Element 7 not found
```
#
3. Инициализатор не гарантирует создание экземпляра
Могли быть обстоятельства, при которых инициализатор типа может не быть в состоянии создать валидный случай. Это может быть связано с тем, что некоторые или все аргументы не являются допустимыми или не выполняются другие требуемые условия.
Чтобы справиться с такими ситуациями, swift позволяет объявить **failable initializer**, который возвращает опциональный экземпляр. Если создание экземпляра завершается неуспешно, возвращается значение nil. **Failable initializer** объявляется путем указания вопросительного знака (?) перед открывающей скобкой списка параметров.

Если смотреть на класс Person, определенный выше, свойство **name** для **Person** не является опциональным, так как каждый человек должен иметь имя. Но мы можем создать безымянного человека, передав пустую строку в качестве аргумента.
```
let namelessPerson = Person(named: "")
```
Чтобы этого не произошло, мы можем изменить класс Person
  
```
class Person {
    var name: String
    var pet: Pet?
    
    init?(named name: String) {
        guard !name.isEmpty else { return nil }
  
        self.name = name
    }
}
```
Теперь невозможно инициализировать экземпляр **Person** с пустой строкой имени.
```
let notAPerson = Person(named: "")
print(type(of: notAPerson))     // Optional<Person>
print(notAPerson == nil)        // true
```
#
4. Параметр функции не требуется в каждом случае
Для каждого вызова функции могут не потребоваться все ее параметры.
Дополнительные параметры обеспечивают элегантный способ обработки таких случаев.
При использовании такой функции для каждого опционального параметра, вызывающий объект должен либо передать значение типа, обернутого как опциональный,
либо использовать **nil**. В качестве альтернативы опциональному параметру может быть присвоено **nil** значение по умолчанию,
что дает вызывающему абоненту возможность вызова функции с таким количеством аргументов, которое может иметь смысл для конкретного вызова,
это также относится к инициализаторам.
 
```
class Cat: Pet {
    var name: String?

    init(named name: String? = nil) {
        self.name = name
    }
    
    func makeSound() {
        print("Meow")
    }
}
```
Мы определили инициализатор с параметром типа **String?**, со значением по умолчанию **nil**.
Этот инициализатор можно использовать для создания экземпляров Cat с именем или без него.
```
let unnamedCat = Cat()
let namedCat = Cat(named: "Bella")
```
#
5. Приведение типов
Когда мы приводим от подтипа к супертипу, то приведение к типу гарантированно будет успешным.
То же самое справедливо при приведении экземпляра конкретного типа к типу протокола, которому соответствует конкретный тип.
Для приведения к типу, который гарантированно будут успешными, мы используем `as` в качестве оператора.
```
var cat = Cat()
var somePet: Pet = cat as Pet
```
Однако, когда мы приводим от супертипа к подтипу или от типа протокола к конкретному типу, мы не можем использовать оператор `as`, так как такие приведения к типу не гарантировано будут успешны. Мы демонстрируем это, используя переменные **somePet** и **cat**.
```
somePet = Pet()
cat = somePet as Cat
// Error: 'Pet' is not convertible to 'Cat'
```
Хотя экземпляр, который мы пытаемся привести, относится к классу **Cat**, мы получаем ошибку компилятора. Это связано с тем, что переменная **somePet** содержит тип **Pet**, и компилятор не может быть уверен, что тип исполняемого экземпляра, который мы пытаемся привести, всегда будет таким, для которого приведение будет успешным.

Для приведения к типу, который не гарантированно будут успешным, мы можем установить оператор `as` с вопросительным знаком(?). В случае успеха приведения, мы получаем результат приведения к типу, завернутый как опциональный.
```
var maybeCat = somePet as? Cat
print(type(of: maybeCat))    // Optional<Cat>
print(maybeCat == nil)       // false
```
Если приведение типа терпит неудачу, мы получаем `nil`. Чтобы продемонстрировать это, мы определяем класс `Dog`, который также соответствует `Pet`.
```
class Dog: Pet {
    var name: String?

    init(named name: String? = nil) {
        self.name = name
    }
    
    func makeSound() {
        print("Woof")
    }
}

somePet = Dog()
maybeCat = somePet as? Cat
print(maybeCat == nil)       // true
```
#
6. Упрощенная обработка ошибок
Опциональность обеспечивает удобное средство для обработки простых ошибок, где причину ошибки можно легко определить из контекста.
Обычный способ обработки ошибок в Swift - поместить любой оператор или вызов функции, которые могут вызвать ошибку в **выражение try**.
Если возникает ошибка, она должна быть обработана каким-либо образом, либо путем ее захвата оператором **do-catch**, либо путем ее распространения,
помечая функцию как **throwing**.

Однако могут возникать ситуации, когда для конкретного случая требуется только знать, была ли вызвана ошибка, а не знать какая имеено это ошибка.
Это может пригодиться при использовании фреймворков и сторонних библиотек, где нас могут не интересовать детали некоторых ошибок, а только случаи сбоя.
  
```
enum TestError: Error {
    case someError
}

func possibleThrower(shouldThrow: Bool) throws -> String {
    if shouldThrow {
        throw TestError.someError
    }
    return "My string"
}
```
Мы можем использовать вышеуказанную функцию, чтобы увидеть результат `try?` выражения, когда функция `throwing` фактически порождает ошибку, так и когда она этого не делает.
```
var stringResult = try? possibleThrower(shouldThrow: false)
print(type(of: stringResult))   // Optional<String>
print(stringResult == nil)      // false

stringResult = try? possibleThrower(shouldThrow: true)
print(stringResult == nil)      // true
```
Когда функция `try?` выражения не вызывает ошибки, мы получаем опциональную упаковку возвращаемого значения функции. Когда возникает ошибка, мы получаем `nil` для обозначения провала.
Это относится к функциям с возвращаемым типом. Но как насчет функций без возвращаемого типа? Интересно, что в Swift нет такой вещи,
как функция без возвращаемого типа. Функции без возвращаемого типа, неявно, имеют возвращаемый тип `Void` и специальное возвращаемое значение `()`,
которое является пустым кортежем, тем самым опциональность может быть использована для `Void` тоже.

```
func anotherPossibleThrower(shouldThrow: Bool) throws {
    if shouldThrow {
        throw TestError.someError
    }
}

var voidResult: Void? = try? anotherPossibleThrower(shouldThrow: false)
print(voidResult == nil)    // false

voidResult = try? anotherPossibleThrower(shouldThrow: true)
print(voidResult == nil)    // true
```
Функция **anotherPossibleThrower** имеет неявный возвращаемый тип **Void**, который становится Void? когда мы используем `try?` выражение.
Мы можем зафиксировать неявное возвращаемое значение, чтобы проверить, равно ли оно `nil`, означающее, что произошла ошибка.
Обратите внимание, что мы должны явным образом объявить тип переменной **voidResult**, чтобы избежать получения предупреждения от компилятора за попытку
захвата возвращаемого значения, которое мы явно не объявили.  
