# Типы ссылок 
Всего в Swift **три** счетчика ссылок: **strong**, **weak** и **unowned**. 

Объект живет в памяти пока на него есть `хотя бы одна strong ссылка`. 
И если объекты ссылаются перекрестными сильными ссылками, то они никогда не уничтожаются. 
Чтобы этого избежать, нужно одним из объектов сослаться **weak** или **unowned** ссылкой на другой. 
Если в момент обращения к weak переменной на объект уже нет strong ссылок, тогда мы получим **nil**. А при обращении к **unowned** будет выброшено исключение.

# Как было раньше?

Прежде как перейти к текущей реализации счетчиков ссылок, хочется упомянуть старую, чтобы прояснить, для чего сделали новые механизмы и какие проблемы решили.
До Swift 4, счетчики ссылок располагались для свойств класса прямо в объекте. Класс имел только два счетчика — **weak** и **strong**.

![image](https://user-images.githubusercontent.com/47610132/178139686-0ce682b0-dce3-4fab-9a1c-cceb04bb8c9b.png)

На объект начинает ссылаться два внешних объекта — один сильно, другой слабо, счетчики прибавляются по одному.

![image](https://user-images.githubusercontent.com/47610132/178139760-27ba28df-27e5-40be-a6be-79732f7b28a4.png)

В один момент времени объект с сильной ссылкой удаляется из памяти, и теперь у нас осталась только одна слабая ссылка. Что происходит в этот момент?

![image](https://user-images.githubusercontent.com/47610132/178139782-2d8f38e2-4889-4d0e-b79f-5cae529e9a52.png)

Данные объекта уничтожаются, но память не освобождается, так как счетчик еще требуется хранить. В памяти остается так называемый «зомби объект», на который ссылается слабая ссылка. Только при обращении по слабой ссылке в runtime будет выполнена проверка: «зомби» (NSZombie) этот объект или нет. Если да, счетчик ссылок уменьшается.

Xcode умеет находить такие объекты и сообщать о них, плюс [имеет инструмент для этого](https://help.apple.com/instruments/mac/current/#/dev612e6956).

Данный подход достаточно прозрачный, но главный минус в том, что так объекты могут долго оставаться в памяти, занимая лишнее место, хотя не несут никакой пользы.
Встречался еще один достаточно критичный баг: получение (загрузка) объекта по слабой ссылке было не потокобезопасным!

```
import Foundation

class Target {}

class WeakHolder {
   weak var weak: Target?
}

for i in 0..<1000000 {
   print(i)
   let holder = WeakHolder()
   holder.weak = Target()
   dispatch_async(dispatch_get_global_queue(0, 0), {
       let _ = holder.weak
   })
   dispatch_async(dispatch_get_global_queue(0, 0), {
       let _ = holder.weak
   })
}
```

Данный кусок кода может получить ошибку в **Runtime**. Суть именно в том механизме, который был рассмотрен ранее. Два потока могут одновременно обратиться к объекту по слабой ссылке. Перед тем, как получить объект, они проверяют, является ли проверяемый объект «зомби». И если оба потока получат ответ true, они отнимут счётчик и постараются освободить память. Один из них сделает это, а второй просто вызовет краш, так как попытается освободить уже освобожденный участок памяти.
Такая реализация не очень хороша и с этим нужно что-то делать.

# Side table
Это дополнительная область памяти в которой хранится дополнительная информация об объекте. 
Она опциональна, это означает что она не обязательно будет присутствовать у объекта. 
Объекты которые нуждаются в ней - несут некоторые потери в производительности, а те которым она не нужна не испытывают ее “нагрузки”.
    
Вместо того чтобы указывать на сам объект, слабые ссылки теперь указывают на побочную таблицу. 
Так как побочные таблицы занимают немного места — мы избавляемся от проблемы растраты памяти из-за слабых ссылок на большие объекты. 
Это наталкивает на простое решение проблемы потокобезопасности: не обнулять слабые ссылки. 

Так как побочные таблицы малы в размере, мы можем сохранять слабые ссылки на нее пока сами ссылки не будут перезаписаны или уничтожены.
Как только мы начинаем ссылаться на объект слабо `weak reference` - то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу.

Сама боковая таблица также имеет ссылку на объект. Еще боковая таблица может создаваться, когда `происходит переполнение счетчика`, и он уже не помещается в поле (счетчики ссылок будут маленькими на 32-битных машинах).

С таким механизмом слабые ссылки ссылаются не напрямую на объект, а на боковую таблицу, которая указывает на объект. Это решает две предыдущие проблемы:
  - Экономие памяти: объект удаляется из памяти, если на него больше нет сильных ссылок.
  - Это позволяет безопасно обнулять слабые ссылки, поскольку слабая ссылка теперь не указывает напрямую на объект и не является предметом `race condition.`

# Как устроена side table 
Вот так **side table** выглядит в [исходниках языка](https://github.com/apple/swift/blob/c39901d7fb34debbaf51d225b01f2869cd0b101f/stdlib/public/SwiftShims/RefCount.h#L1310): 
```class HeapObjectSideTableEntry {
  std::atomic<HeapObject*> object;
  SideTableRefCounts refCounts;
}
```
  - В самом первом поле хранится указатель на объект, которому принадлежит эта **side table**. 
  - Следом лежит его счетчик ссылок, представленный структурой типа **SideTableRefCounts**. Внутри нее хранится битовое поле со счетчиками ссылок и флагами.

Side table работает в паре с классом [**WeakReference**](https://github.com/apple/swift/blob/9a5bb49067e21d33c73b32843dcc95f8a88d7a9d/stdlib/public/runtime/WeakReference.h#L156). По сути экземпляр класса WeakReference создается для каждой новой weak переменной. 
И взаимодействие со свойствами и методами объекта происходит через него. Класс WeakReference определен следующим образом:
```
class WeakReference {
  union {
    std::atomic<WeakReferenceBits> nativeValue;
#if SWIFT_OBJC_INTEROP
    id nonnativeValue;
#endif
  };
}
```
  - `nativeValue` сохраняется указатель на нативный объект. Нативным называется объект, структура которого известна рантайму Swift и он может жить без рантайма Objective-C.
  - `nonnativeValue` сохраняется объект, который наследуется от NSObject и им  управляет рантайм Objective-C.

Так как это объединение, то в один момент может хранится только одно значение. Флаг `SWIFT_OBJC_INTEROP` указывает на то, 
нужна ли интероперабельность с Objective-C – то есть можно ли из Swift кода работать с объектами Objective-C. 
На всех платформах от Apple этот флаг активирован. 

# Как работает WeakReference
**WeakReference** хранит указатель на оригинальный объект. 
И для его получения вызывается функция **swift_weakLoadStrong**. 
Она принимает **WeakReference** единственным аргументом и возвращает указатель на **HeapObject**. 
Вызов **swift_weakLoadStrong** также увеличивает на единицу количество strong ссылок. 
Эта дополнительная единица сохраняется до конца текущей области видимости weak переменной. 

В конце области видимости **strong** счетчик уменьшается на единицу. 
А когда объект уже деалоцирован, то вызов **swift_weakLoadStrong** вернет **null**. 
Таким образом, в рантайме реализуется семантика слабых ссылок. 
Ведь экземпляр **HeapObject** физически еще присутствует в памяти. 
А **WeakReference** выступает в роли обертки и проверяет, не уничтожен ли еще объект с точки зрения рантайма. 

# Счетчик ссылок
Счетчик ссылок хранится внутри структуры **HeapObject**. **HeapObject** – это внутреннее представление объекта в рантайме. То есть каждый экземпляр класса в рантайме это экземпляр структуры с типом **HeapObject**.

В алгоритме работы счетчика ссылок определено пять состояний, в которых объект находится на всем пути от создания до удаления из памяти. 
Можно провести параллель с жизненным циклом **UIViewController**. 
Он создается, отображает визуальные элементы, реагирует на вызовы от операционной системы и в конце деаллоцируется. 
Состояния объекта перечислены ниже:

1. `Live` – объект создан и находится в памяти.
2. `Deiniting` – объект находится в процессе деинициализации, то есть у него вызван метод `deinit`.
3. `Deinited` – объект полность деинициализирован.
4. `Freed` – выделенная память под объект освобождена, но `side table` еще существует.
5. `Dead` – память занятая side table освобождается.

![image](https://user-images.githubusercontent.com/47610132/176542135-43d31345-7d44-4197-bafa-96b37afc7e69.png)

  - `Live` его счетчики инициализируются со значениями strong — 1, unowned — 1, weak — 1. 
На данный момент нет боковой таблицы. Операции с **unowned** переменными работают нормально. Когда `strong reference count` достигает нуля, вызывается deinit(), и объект переходит в следующее состояние (deiniting).
  - `Deiniting` - на данном этапе операции со `strong` ссылками не действуют. При чтении через **unowned** ссылку будет срабатывать **assertion failure**. 
Но новые **unowned** ссылки еще могут добавляться. Если есть боковая таблица, то **weak** операции будут возвращать nil. Далее из этого состояния уже можно перейти в два других.
  - Если нет боковой таблицы, т.e нет `weak ссылок` и нет `unowned ссылок`, то объект переходит в `Dead` состояние и сразу удаляется из памяти.
  - Если у нас есть `unowned или weak ссылки`, объект переходит в состояние `Deinited`. 
В этом состоянии функция deinit() завершена, сохранение и чтение сильных или слабых ссылок невозможно. 
Как и сохранение новых `unowned ссылок`. При попытке чтения `unowned ссылки` вызывается assertion failure. Из этого состояния также возможно два исхода.
  - В случае наличия `weak ссылок`, а значит и боковой таблицы, осуществляется переход в состояние `Freed`. 
В `Freed` состоянии объект уже полностью освобожден и не занимает места в памяти, но его боковая таблица остается жива.
  - После того как счетчик слабых ссылок достигает нуля, боковая таблица также удаляется и освобождает память, и осуществляется переход в финальное состояние — `Dead`. 
В этом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на `HeapObject` освобождается из кучи, не оставляя следов объекта в памяти.

# Инварианты счетчиков ссылок
Весь жизненный цикл сопровождается инвариантами счетчиков ссылок. 
Инвариантность  —  это выражение, определяющее непротиворечивое внутреннее состояние объекта.

- Если счетчик strong ссылок становится равен нулю, то объект всегда переходит в состояние **deiniting**. `Unowned` ссылки выкидывают ошибку в **runtime**, а чтение **weak** ссылок возвращает **nil**.
- Счетчик `unowned` ссылок получает +1 от счетчика strong ссылок, который впоследствие уменьшается после завершения функции `deinit()` объекта.
- Счетчик weak ссылок получает +1 от счетчика `unowned` ссылок. Он уменьшается после освобождения (freed) объекта из памяти.

# Дополнительные материалы:
- [RefCount.h at Swift repo](https://github.com/apple/swift/blob/main/stdlib/public/SwiftShims/RefCount.h)
- [Object life cycle](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectLifeCycle.html)
- [Swift 4 Weak References](https://mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html)
- [Swift 4 — слабые ссылки](https://habr.com/ru/post/341014/)
